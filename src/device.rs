use sdl2::EventPump;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::audio::{AudioCallback, AudioSpecDesired, AudioDevice};
use keyboard::Keyboard;
use display::Display;


const SBUFF: [u8; 288] = [
    0xa8, 0xc1, 0xc9, 0xce, 0xd3, 0xd8, 0xd9, 0xdd,
    0xe0, 0xe1, 0xe3, 0xe4, 0xe6, 0xe7, 0xe9, 0xe8,
    0xeb, 0xec, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xee,
    0xf0, 0xf1, 0xf0, 0xf1, 0xf0, 0xf2, 0xf1, 0xf2,
    0xf3, 0xf2, 0xf4, 0xf3, 0xf4, 0xf3, 0xf4, 0xf4,
    0xf3, 0xf5, 0xf5, 0xf5, 0xf4, 0xf5, 0xf5, 0xf6,
    0xf4, 0xf6, 0xf6, 0xf6, 0xf5, 0xf6, 0xf5, 0xf6,
    0xf6, 0xf5, 0xf6, 0xf5, 0xf6, 0xf6, 0xf6, 0xf6,
    0xf5, 0xf4, 0xf5, 0xf4, 0xf5, 0xf5, 0xf4, 0xf5,
    0xf5, 0xf4, 0xf5, 0xf4, 0xf4, 0xf3, 0xf4, 0xf3,
    0xf3, 0xf3, 0xf2, 0xf3, 0xf2, 0xf3, 0xf2, 0xf3,
    0xf2, 0xf1, 0xf2, 0xf1, 0xf2, 0xf0, 0xf1, 0xf0,
    0xf1, 0xf0, 0xf0, 0xef, 0xf0, 0xef, 0xef, 0xef,
    0xee, 0xef, 0xed, 0xee, 0xee, 0xed, 0xed, 0xed,
    0xec, 0xed, 0xec, 0xeb, 0xec, 0xec, 0xea, 0xeb,
    0xea, 0xeb, 0xea, 0xea, 0xea, 0xe9, 0xe9, 0xe9,
    0xe8, 0xe9, 0xe8, 0xe8, 0xe7, 0xe8, 0xe7, 0xe7,
    0xe6, 0xe7, 0xe6, 0xe5, 0xe5, 0xe5, 0xe6, 0xe4,
    0xe6, 0xe4, 0xd5, 0xaa, 0x71, 0x44, 0x33, 0x32,
    0x31, 0x29, 0x24, 0x22, 0x21, 0x1f, 0x1b, 0x19,
    0x1a, 0x19, 0x15, 0x15, 0x14, 0x14, 0x13, 0x11,
    0x12, 0x10, 0x10, 0x0e, 0x0f, 0x0e, 0x0e, 0x0d,
    0x0c, 0x0d, 0x0d, 0x0b, 0x0c, 0x0b, 0x0c, 0x0a,
    0x0b, 0x0a, 0x0b, 0x09, 0x0a, 0x09, 0x0a, 0x09,
    0x0a, 0x0a, 0x09, 0x09, 0x08, 0x09, 0x09, 0x08,
    0x09, 0x08, 0x09, 0x08, 0x09, 0x09, 0x08, 0x09,
    0x08, 0x09, 0x09, 0x08, 0x09, 0x09, 0x08, 0x0a,
    0x09, 0x0a, 0x09, 0x0a, 0x09, 0x0a, 0x09, 0x0a,
    0x0a, 0x0b, 0x0a, 0x0b, 0x0a, 0x0b, 0x0a, 0x0b,
    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0c,
    0x0d, 0x0d, 0x0e, 0x0c, 0x0d, 0x0e, 0x0e, 0x0e,
    0x0d, 0x0f, 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x11,
    0x10, 0x11, 0x11, 0x12, 0x10, 0x11, 0x12, 0x13,
    0x12, 0x12, 0x14, 0x14, 0x13, 0x13, 0x13, 0x16,
    0x13, 0x14, 0x14, 0x17, 0x16, 0x14, 0x16, 0x17,
    0x18, 0x14, 0x16, 0x19, 0x1a, 0x15, 0x16, 0x1a,
];

pub struct Device<'d> {
    pub audio: AudioDevice<Beep>,
    display: Display<'d> ,
    pub keyboard: Keyboard,
    pump: EventPump,
    pub quit: bool,
}


impl<'d> Device<'d> {
    pub fn new() -> Device<'d> {
        let context = ::sdl2::init().unwrap();
        let pump = context.event_pump().unwrap();
        let audio_subsystem = context.audio().unwrap();
        let desired_spec = AudioSpecDesired {
            freq: Some(44100),
            channels: Some(1),
            samples: Some(288),
        };

        let beep = audio_subsystem.open_playback(None, &desired_spec, | s | {
            Beep{}
        }).unwrap();

        Device {
            audio: beep,
            display: Display::new(context),
            keyboard: Keyboard::new(),
            pump: pump,
            quit: false,
        }
    }
    pub fn pump(&mut self) {
        for event in self.pump.poll_iter() {
            match event {
                Event::KeyDown { keycode, .. } => match keycode {
                    Some(Keycode::Escape) => self.quit = true,
                    _ => self.keyboard.handle_event(event)
                },
                Event::KeyUp { .. } => self.keyboard.handle_event(event),
                Event::Quit { .. } => self.quit = true,
                _ => {}
            }
        }
    }
    pub fn write_bytes(&mut self, byte: Vec<u8>, x: usize, y:usize) -> u8 {
        self.display.write_bytes(byte, x, y)
    }
    pub fn clear_display(&mut self) {
        self.display.clear();
    }
    pub fn draw(&mut self) {
        self.display.draw()
    }
}


pub struct Beep {}

impl AudioCallback for Beep {
    type Channel = u8;

    fn callback(&mut self, out: &mut [u8]) {
        for i in 0..SBUFF.len() {
            out[i] = SBUFF[i];
        }
    }
}